##
## We want to monitor individual shower usage in student dormitories.
## Thus, we develop a device that is attached to the showerhead that measures temperature and water flow.
## The node collects measurements, encrypts them and sens to the backend via Bluetooth suing "data mules" when the connection is available.
## Data mule is a mobile phone application that forwards the data to the cloud. It counts and shows to the user how many records has passed through.
## The user can manually add "I showered" event.
## The device configuration can be sent from web interface to the embedded device
##

## we identify following sink and sources
sources:
temperature sensor
flow-meter
weather temperature
sinks:
database
node LED

## we identify following models:
Application
Temperature, local model in the node
Flow, local model in node
Measurement, streaming model
Number of records, local model in the gateway
Device Location, cloud model denoting the location of the device
Device type, describing various kinds of the devices in the application
System:
Application Configuration, updatable parameters in the app
The device, information about the tier (embedded, gateway, cloud)
Administrator, application access, and administration

## transforms
FFT: ADC measurements to flow-model
Record counter

## views
View Number of records on the gateway
Cloud, view/update/delete records


### system MVC
# model describes the device that is present in the application

replicated model AppDevice:
    flow:
        source = self.schema
        sink = CloudSpace.sinks.db
        origins = [local, CloudSpace]
        destinations = [CloudSpace]


    properties:
        origin = EmbeddedSpace, CloudSpace
        destination = EmbeddedSpace, CloudSpace
        source = bootstrap, AppDeviceEditor
        sink = CloudSpace.db
        log = ALL # shortcut for replicated & streaming
        durable = True
        size = 10
        access = SYSTEM(RW), ADMIN(RW, limit=(id,type, hw_v, app_v)), TIERS(E,C)
        encrypt = AES(ALL)


    schema:
        id = UUID(auto_create=True)
        type = DeviceType()
        hw_v = Version()
        sw_v = Version()
        first_boot = bool(default=False)
        last_reboot = TimeDateStamp(auto_add=True)
        error = Text()

controller EmBootstrapController:
    configuration:
        app_device = AppDevice()
        system = SystemEvents()

    event system.boot(context cntx):
        time.start_and_repeat(embedded_config.adc_sampling)
        rec = app_device.get_or_create()
        rec.error = cntx.error
        rec.save()

    event app_device.save_done(context cntx):
        if cntx.error == SUCCESS:
            app_device.delete(cntx.record)

    event app_device.full(context cntx):
        delete app_device.first()

view AppDeviceEditor:
    # gives access to the records and the model for sync
    configuration:
        system = HTTP

    event system.request(context cntx):
        if cntx.POST:
            device.get_and_update(cntx.model)
        else:
            system.render_html(device.get(cntx.QUERY))

replicated model EmbeddedAppConfig:
    flow:
        source = self.schema
        sink = CloudSpace.sinks.db
        origins = ALL # shortcut for [EmbeddedSpace, GatewaySpace, CloudSpace]
        destinations = [local,GatewaySpace,CloudSpace]

    properties:
        log = ALL
        durable = True
        encrypt = AES(ALL)
        access = ADMIN(RW)

    schema:
        device = AppDevice()
        ble_broadcast = Second(default=1.5)
        adc_sampling = Second(default=1)
        measurement_size = Integer(default=250, max=500)
        key = byte(size=32)


controller EmbeddedAppConfigController:
    configuration:
        app_model = EmbeddedAppConfig()


    event app_model.updated(context ctx):
        if ctx.error == SUCCESS:
            #error handling
        else if ctx.error == ERROR:
            #error handling

view EmbeddedAppConfigView:
        configuration:
            system = HTTP

        event system.request(context cntx):
            if cntx.POST:
                device_app_config.get_and_update(cntx.model)
            else:
                system.render_html(device.get(cntx.QUERY))

replicated model GatewayAppConfig:
    flow:
        source = self.schema
        sink = CloudSpace.sinks.db
        origins = [local, CloudSpace]
        destinations = [local,CloudSpace]

    properties:
        origin = GatewaySpace, CloudSpace
        destination = GatewaySpace, CloudSpace
        source = app_process, AppDeviceEditor
        sink = CloudSpace.db
        log = ALL # shortcut for replicated & streaming
        durable = True
        size = 10
        access = SYSTEM(RW), ADMIN(RW, limit=(id,type, hw_v, app_v)), TIERS(G,C)
        encrypt = AES(ALL)

    schema:
        id = UUID(auto_create=True)
        type = DeviceType()
        hw_v = Version()
        sw_v = Version()
        first_boot = boolean(default=False)
        last_reboot = TimeDateStamp(auto_add=True)
        error = Text()

controller GatewayAppConfigController:
    configuration:
        app_model = GatewayAppConfig()

    event app_model.updated(context ctx):
        if ctx.error == SUCCESS:
            #error handling
        else if ctx.error == ERROR:
            #error handling


controller AppModelController:
    configuration:
        app_model = AppModel()

    event app_model.updated(context ctx):
        if ctx.error == SUCCESS:
            #error handling
        else if ctx.error == ERROR:
            #error handling


### Application MVC

local model ADCModel:
    flow:
        source = self.sources.device.VoltageIO
        sink = None
        origins = local
        destinations = local

    properties:
        durable = False
        size = 250

    schema:
        adc = Integer(min)

streaming model Measurement:
        flow:
            source = [
                voltage=self.ADCModel,
                temperature = self.sources.Temperature
                ]
            sink = None
            origins = local
            destinations = local

        properties:
            reliable = ALL
            encryption = OCB(ALL)

        schema:
            time = TimestampField(auto_add_on_save=True)
            temperature = Integer()
            voltage = Integer()

controller MeasurementController:
    configuration:
        temp = EmbeddedSpace.source.TEMPERATURE
        error_margin = 0.9

    event timer.expired(context c):
        vol = voltage.READ #read new value
        prev = adc_model.last() #get last value
        if vol < (prev-error_margin) or vol > (prev+error_margin):
            #needs error handling
            v = adc_model.create() # create new record
            v.adc = vol
            v.save()

    # model events, produced after save
    event measurement_model.saveDone(context c):
        if c.error == SUCCESS:
            delete measurement_model.local.first()

    event adc_model.full(context c):
        # we have 250 records of ADC, lets create a measurement
        m = measurement_model.create()
        m.temperature = temp.READ
        m.voltage = transforms.FFT(adc_model.voltage)
        m.save() #save measurement
        adc_model.clear() #delete all values in queue

local model NumberOfPackets:
    flow:
        source = None
        sink = None
        origins = local
        destinations = local

    properties:
        size = 1

    schema:
        number_of_packets = Counter(auto_update=True, start=0, type=Integer, step=1)

controller NumberOfPacketsController:
    configuration:
        packet_arrived = Measurement.arrived

    event packet_arrived(context cntx):
        num_packets.number_of_packets.update()

view NumberOfPacketsView:
    config:
        ui_view = UI.text
        previous = UnsignedInteger32(default = Null)

    command update(context c):
        if previous == (null or !c.value):
            previous = c.value
            ui_view.refresh(previous)

space EmbeddedSpace:
    properties:
        # should describe the hardware platform
        # so that Ravel can verify that model size
        # and other configurations, properties are achievable
        max_storage = 500 MB
        communication = BLE(GatewaySpace)
        language = c

	configuration:
	    language_templates = 'C/'
		platform_templates = 'nrf51/'
		user_templates = 'workspace/tethys/templates/'
		libs = 'templates/c/tethys/'
		timer = System.Timer.RTC

	models:
	    app_device = AppDevice
	    adc_model = ADCModel
		measurement_model = Measurement
		device = DeviceModel
		embedded_config = EmbeddedAppConfig

	controllers:
	    boot=BootstrapController
		measure = MeasurementController

	sources:
		temperature = device.Temperature
		voltage = device.VoltageIO


space GatewaySpace:
    properties:
        max_storage = 5000MB
        communication = BLE(EmbeddedSpace), ANY(CloudSpace)

    configuration:
        language_templates = 'java'
        platform_templates = 'Android/API23/'

    models:
        app_config = GatewayAppConfig
        num_packets = NumberOfPackets

    controllers:
        app_process = GatewayAppConfigController
        packet_counter = NumberOfPacketsController

    views:
        number_of_packet_view = NumberOfPacketsView


space CloudSpace:
    properties:
        max_storage = None

    configuration:
	    language_templates = 'python'
		platform_templates = 'django/'
		user_templates = 'workspace/tethys/templates/'

	models:
	    device = AppDevice
		temp = TemperatureModel
		device = DeviceModel
		embedded_config = EmbeddedAppConfig

	controllers:
	    bootstrap = EmBootstrapController
		temp_c = MeasurementController

	views:
	    device_config = AppDeviceEditor
	    device_app_config = EmbeddedAppConfigView

    sinks:
        db = sqlite3