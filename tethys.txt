##
## We want to monitor individual shower usage in student dormitories.
## Thus, we develop a device that is attached to the showerhead that measures temperature and water flow.
## The node collects measurements, encrypts them and sens to the backend via Bluetooth suing "data mules" when the connection is available.
## Data mule is a mobile phone application that forwards the data to the cloud. It counts and shows to the user how many records has passed through.
## The user can manually add "I showered" event.
## The device configuration can be sent from web interface to the embedded device
##

## we identify following sink and sources
sources:
temperature sensor
flow-meter
weather temperature
sinks:
database
node LED

## we identify following models:
Application
Temperature, local model in the node
Flow, local model in node
Measurement, streaming model
Number of records, local model in the gateway
Device Location, cloud model denoting the location of the device
Device type, describing various kinds of the devices in the application
System:
Application Configuration, updatable parameters in the app
The device, information about the tier (embedded, gateway, cloud)
Administrator, application access, and administration

## transforms
FFT: ADC measurements to flow-model
Record counter

## views
View Number of records on the gateway
Cloud, view/update/delete records


### system MVC
# model describes the device that is present in the application

replicated model AppDevice:
    flow:
        source = self.schema
        sink = CloudSpace.sinks.db
        origins = [local, CloudSpace]
        destinations = [CloudSpace]
	END

    properties:
        origin = EmbeddedSpace, CloudSpace
        destination = EmbeddedSpace, CloudSpace
        source = bootstrap, AppDeviceEditor
        sink = CloudSpace.db
        log = ALL # shortcut for replicated & streaming
        durable = True
        size = 10
        access = SYSTEM(RW), ADMIN(RW, limit=(id,type, hw_v, app_v)), TIERS(E,C)
        encrypt = AES(ALL)
	END


    schema:
        id = UUID(auto_create=True)
        type = DeviceType()
        hw_v = Version()
        sw_v = Version()
        first_boot = bool(default=False)
        last_reboot = TimeDateStamp(auto_add=True)
        error = Text()
	END
END

controller EmBootstrapController:
    configuration:
        app_device = AppDevice()
        system = SystemEvents()
	END

    event system.boot(context cntx):
        time.start_and_repeat(embedded_config.adc_sampling)
        rec = app_device.get_or_create()
        rec.error = cntx.error
        rec.save()
	END

    event app_device.save_done(context cntx):
        if cntx.error == SUCCESS:
            app_device.delete(cntx.record)
	END

    event app_device.full(context cntx):
        delete app_device.first()
	END
END

view AppDeviceEditor:
    # gives access to the records and the model for sync
    configuration:
        system = HTTP
	END

    event system.request(context cntx):
        if cntx.POST:
            device.get_and_update(cntx.model)
        else:
            system.render_html(device.get(cntx.QUERY))
	END

replicated model EmbeddedAppConfig:
    flow:
        source = self.schema
        sink = CloudSpace.sinks.db
        origins = ALL # shortcut for [EmbeddedSpace, GatewaySpace, CloudSpace]
        destinations = [local,GatewaySpace,CloudSpace]
	END

    properties:
        log = ALL
        durable = True
        encrypt = AES(ALL)
        access = ADMIN(RW)
	END

    schema:
        device = AppDevice()
        ble_broadcast = Second(default=1.5)
        adc_sampling = Second(default=1)
        measurement_size = Integer(default=250, max=500)
        key = byte(size=32)
	END
END

controller EmbeddedAppConfigController:
    configuration:
        app_model = EmbeddedAppConfig()
	END

    event app_model.updated(context ctx):
        if ctx.error == SUCCESS:
            #error handling
        else if ctx.error == ERROR:
            #error handling
	END
END

view EmbeddedAppConfigView:
    configuration:
        system = HTTP
	END

    event system.request(context cntx):
        if cntx.POST:
            device_app_config.get_and_update(cntx.model)
        else:
            system.render_html(device.get(cntx.QUERY))
    END
END

replicated model GatewayAppConfig:
    flow:
        source = self.schema
        sink = CloudSpace.sinks.db
        origins = [local, CloudSpace]
        destinations = [local,CloudSpace]
	END
    properties:
        origin = GatewaySpace, CloudSpace
        destination = GatewaySpace, CloudSpace
        source = app_process, AppDeviceEditor
        sink = CloudSpace.db
        log = ALL # shortcut for replicated & streaming
        durable = True
        size = 10
        access = SYSTEM(RW), ADMIN(RW, limit=(id,type, hw_v, app_v)), TIERS(G,C)
        encrypt = AES(ALL)
	END

    schema:
        id = UUID(auto_create=True)
        type = DeviceType()
        hw_v = Version()
        sw_v = Version()
        first_boot = boolean(default=False)
        last_reboot = TimeDateStamp(auto_add=True)
        error = Text()
    END
END

controller GatewayAppConfigController:
    configuration:
        app_model = GatewayAppConfig()
    END

    event app_model.updated(context ctx):
        if ctx.error == SUCCESS:
            #error handling
        else if ctx.error == ERROR:
            #error handling
    END
END

controller AppModelController:
    configuration:
        app_model = AppModel()
    END

    event app_model.updated(context ctx):
        if ctx.error == SUCCESS:
            #error handling
        else if ctx.error == ERROR:
            #error handling
    END
END

### Application MVC

local model ADCModel:
    flow:
        source = self.sources.device.VoltageIO
        sink = None
        origins = local
        destinations = local
    END

    properties:
        durable = False
        size = 250
    EMD

    schema:
        adc = Integer(min)
    END
END

streaming model Measurement:
    flow:
        source = [
            voltage=self.ADCModel,
            temperature = self.sources.Temperature
            ]
        sink = None
        origins = local
        destinations = local
    END

    properties:
        reliable = ALL
        encryption = OCB(ALL)
    END

    schema:
        time = TimestampField(auto_add_on_save=True)
        temperature = Integer()
        voltage = Integer()
    END
END

controller MeasurementController:
    configuration:
        temp = EmbeddedSpace.source.TEMPERATURE
        error_margin = 0.9
    END

    event timer.expired(context c):
        vol = voltage.READ #read new value
        prev = adc_model.last() #get last value
        if vol < (prev-error_margin) or vol > (prev+error_margin):
            #needs error handling
            v = adc_model.create() # create new record
            v.adc = vol
            v.save()
    END

    # model events, produced after save
    event measurement_model.saveDone(context c):
        if c.error == SUCCESS:
            delete measurement_model.local.first()
    END

    event adc_model.full(context c):
        # we have 250 records of ADC, lets create a measurement
        m = measurement_model.create()
        m.temperature = temp.READ
        m.voltage = transforms.FFT(adc_model.voltage)
        m.save() #save measurement
        adc_model.clear() #delete all values in queue
    END
END

local model NumberOfPackets:
    flow:
        source = None
        sink = None
        origins = local
        destinations = local
    END

    properties:
        size = 1
    END

    schema:
        number_of_packets = Counter(auto_update=True, start=0, type=Integer, step=1)
    END
END

controller NumberOfPacketsController:
    configuration:
        packet_arrived = Measurement.arrived
    END

    event packet_arrived(context cntx):
        num_packets.number_of_packets.update()
    END
END

view NumberOfPacketsView:
    config:
        ui_view = UI.text
        previous = UnsignedInteger32(default = Null)
    END

    command update(context c):
        if previous == (null or !c.value):
            previous = c.value
            ui_view.refresh(previous)
    END

space EmbeddedSpace:
    properties:
        # should describe the hardware platform
        # so that Ravel can verify that model size
        # and other configurations, properties are achievable
        max_storage = 500 MB
        communication = BLE(GatewaySpace)
        language = c
    END

	configuration:
	    language_templates = 'C/'
		platform_templates = 'nrf51/'
		user_templates = 'workspace/tethys/templates/'
		libs = 'templates/c/tethys/'
		timer = System.Timer.RTC
    END

	models:
	    app_device = AppDevice
	    adc_model = ADCModel
		measurement_model = Measurement
		device = DeviceModel
		embedded_config = EmbeddedAppConfig
    END

	controllers:
	    boot=BootstrapController
		measure = MeasurementController
    END

	sources:
		temperature = device.Temperature
		voltage = device.VoltageIO
    END
END

space GatewaySpace:
    properties:
        max_storage = 5000MB
        communication = BLE(EmbeddedSpace), ANY(CloudSpace)
    END

    configuration:
        language_templates = 'java'
        platform_templates = 'Android/API23/'
    END

    models:
        app_config = GatewayAppConfig
        num_packets = NumberOfPackets
    END

    controllers:
        app_process = GatewayAppConfigController
        packet_counter = NumberOfPacketsController
    END

    views:
        number_of_packet_view = NumberOfPacketsView
    END
END

space CloudSpace:
    properties:
        max_storage = None
    END

    configuration:
	    language_templates = 'python'
		platform_templates = 'django/'
		user_templates = 'workspace/tethys/templates/'
    END

	models:
	    device = AppDevice
		temp = TemperatureModel
		device = DeviceModel
		embedded_config = EmbeddedAppConfig
    END

	controllers:
	    bootstrap = EmBootstrapController
		temp_c = MeasurementController
    END

	views:
	    device_config = AppDeviceEditor
	    device_app_config = EmbeddedAppConfigView
    END

    sinks:
        db = sqlite3
    END
END