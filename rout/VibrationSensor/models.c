/**
 * Autogenerated file containing data models
 *  models.c
 *
 *  Created on: 11:44:58 10/12/2016
 *      Author: Ravel
 */
//base includes
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
//default buffers
#include "api/ringbuf.h"

#include "models.h"
#include "node_ctr.h" //controller include
//Model common implementations
#define VIBRATION_MODEL__QUEUE_SIZE 50

ghpringbuf *vibration_model__queue_buf ;
uint32_t vibration_model__buff_size = VIBRATION_MODEL__QUEUE_SIZE;
bool vibration_model__buff_full = false;
uint32_t vibration_model__rec_id=0;
uint32_t vibration_model__rec_discarded=0;

//generic buffer implementation
ghpringbuf *buf;
//*record functions:*/
//delete buffer
void vibration_model__destroy(){
    ghpringbuf_destroy(vibration_model__queue_buf);
}
//is buffer full
inline static bool vibration_model__is_full(){
	return vibration_model__queue_buf->capacity == vibration_model__queue_buf->count;
}

//buffer size is defined via VIBRATION_MODEL__QUEUE_SIZE
//init buffer
void vibration_model__innit(){
	vibration_model__queue_buf = ghpringbuf_create(VIBRATION_MODEL__QUEUE_SIZE, sizeof(VibrationModel), 1, NULL);
}
//create record is in place code snippet
VibrationModel vibration_model__create(){
        VibrationModel m_model;
        //allocate the memory
    	memset(&m_model, 0, sizeof(VibrationModel));
    	//loop through the field to set default values
        //return newly created model with set fields
    	return m_model;
}
//save record
void vibration_model__save(VibrationModel *mr) {
	if(!vibration_model__buff_full) {
		ghpringbuf_put(vibration_model__queue_buf, mr);
		vibration_model__rec_id++;
	} else {
		vibration_model__rec_discarded++;
	}
	vibration_model__buff_full = vibration_model__is_full();
	if(vibration_model__buff_full){
		vibration_model__node_ctr__full(mr);
	}
	vibration_model__node_ctr__bufferSaveDone(mr);
}

//delete
void vibration_model__delete(int position) {
    //TODO: fix buffer pop at possition
    //ghpringbuf_pop(position);

}

//* record local queries */
void vibration_model__get(uint32_t position, VibrationModel *rm){
	VibrationModel *a_ptr;
	a_ptr = ghpringbuf_at(vibration_model__queue_buf, position);
	memcpy(&rm, a_ptr, sizeof(VibrationModel));

}
void vibration_model__get_first(VibrationModel *rm){
	VibrationModel *a_ptr;
	a_ptr = ghpringbuf_at(vibration_model__queue_buf, 0);
	memcpy(&rm, a_ptr, sizeof(VibrationModel));

}
void vibration_model__get_last(VibrationModel *rm){
	VibrationModel *a_ptr;
	a_ptr = ghpringbuf_at(vibration_model__queue_buf, 50-1);
	memcpy(&rm, a_ptr, sizeof(VibrationModel));
}

 


#define P_PHASE_MODEL__QUEUE_SIZE 10

ghpringbuf *p_phase_model__queue_buf ;
uint32_t p_phase_model__buff_size = P_PHASE_MODEL__QUEUE_SIZE;
bool p_phase_model__buff_full = false;
uint32_t p_phase_model__rec_id=0;
uint32_t p_phase_model__rec_discarded=0;

//generic buffer implementation
ghpringbuf *buf;
//*record functions:*/
//delete buffer
void p_phase_model__destroy(){
    ghpringbuf_destroy(p_phase_model__queue_buf);
}
//is buffer full
inline static bool p_phase_model__is_full(){
	return p_phase_model__queue_buf->capacity == p_phase_model__queue_buf->count;
}

//buffer size is defined via P_PHASE_MODEL__QUEUE_SIZE
//init buffer
void p_phase_model__innit(){
	p_phase_model__queue_buf = ghpringbuf_create(P_PHASE_MODEL__QUEUE_SIZE, sizeof(pPhaseModel), 1, NULL);
}
//create record is in place code snippet
pPhaseModel p_phase_model__create(){
        pPhaseModel m_model;
        //allocate the memory
    	memset(&m_model, 0, sizeof(pPhaseModel));
    	//loop through the field to set default values
        //return newly created model with set fields
    	return m_model;
}
//save record
void p_phase_model__save(pPhaseModel *mr) {
	if(!p_phase_model__buff_full) {
		ghpringbuf_put(p_phase_model__queue_buf, mr);
		p_phase_model__rec_id++;
	} else {
		p_phase_model__rec_discarded++;
	}
	p_phase_model__buff_full = p_phase_model__is_full();
	if(p_phase_model__buff_full){
		p_phase_model__coordinator_ctr__full(mr);
	}
	p_phase_model__coordinator_ctr__bufferSaveDone(mr);
}

//delete
void p_phase_model__delete(int position) {
    //TODO: fix buffer pop at possition
    //ghpringbuf_pop(position);

}

//* record local queries */
void p_phase_model__get(uint32_t position, pPhaseModel *rm){
	pPhaseModel *a_ptr;
	a_ptr = ghpringbuf_at(p_phase_model__queue_buf, position);
	memcpy(&rm, a_ptr, sizeof(pPhaseModel));

}
void p_phase_model__get_first(pPhaseModel *rm){
	pPhaseModel *a_ptr;
	a_ptr = ghpringbuf_at(p_phase_model__queue_buf, 0);
	memcpy(&rm, a_ptr, sizeof(pPhaseModel));

}
void p_phase_model__get_last(pPhaseModel *rm){
	pPhaseModel *a_ptr;
	a_ptr = ghpringbuf_at(p_phase_model__queue_buf, 10-1);
	memcpy(&rm, a_ptr, sizeof(pPhaseModel));
}

 


#define COMPRESSED_SAMPLE_MODEL__QUEUE_SIZE 10

ghpringbuf *compressed_sample_model__queue_buf ;
uint32_t compressed_sample_model__buff_size = COMPRESSED_SAMPLE_MODEL__QUEUE_SIZE;
bool compressed_sample_model__buff_full = false;
uint32_t compressed_sample_model__rec_id=0;
uint32_t compressed_sample_model__rec_discarded=0;

//generic buffer implementation
ghpringbuf *buf;
//*record functions:*/
//delete buffer
void compressed_sample_model__destroy(){
    ghpringbuf_destroy(compressed_sample_model__queue_buf);
}
//is buffer full
inline static bool compressed_sample_model__is_full(){
	return compressed_sample_model__queue_buf->capacity == compressed_sample_model__queue_buf->count;
}

//buffer size is defined via COMPRESSED_SAMPLE_MODEL__QUEUE_SIZE
//init buffer
void compressed_sample_model__innit(){
	compressed_sample_model__queue_buf = ghpringbuf_create(COMPRESSED_SAMPLE_MODEL__QUEUE_SIZE, sizeof(CompressedSampleModel), 1, NULL);
}
//create record is in place code snippet
CompressedSampleModel compressed_sample_model__create(){
        CompressedSampleModel m_model;
        //allocate the memory
    	memset(&m_model, 0, sizeof(CompressedSampleModel));
    	//loop through the field to set default values
        //return newly created model with set fields
    	return m_model;
}
//save record
void compressed_sample_model__save(CompressedSampleModel *mr) {
	if(!compressed_sample_model__buff_full) {
		ghpringbuf_put(compressed_sample_model__queue_buf, mr);
		compressed_sample_model__rec_id++;
	} else {
		compressed_sample_model__rec_discarded++;
	}
	compressed_sample_model__buff_full = compressed_sample_model__is_full();
	if(compressed_sample_model__buff_full){
		compressed_sample_model__coordinator_ctr__full(mr);
	}
	compressed_sample_model__coordinator_ctr__bufferSaveDone(mr);
}

//delete
void compressed_sample_model__delete(int position) {
    //TODO: fix buffer pop at possition
    //ghpringbuf_pop(position);

}

//* record local queries */
void compressed_sample_model__get(uint32_t position, CompressedSampleModel *rm){
	CompressedSampleModel *a_ptr;
	a_ptr = ghpringbuf_at(compressed_sample_model__queue_buf, position);
	memcpy(&rm, a_ptr, sizeof(CompressedSampleModel));

}
void compressed_sample_model__get_first(CompressedSampleModel *rm){
	CompressedSampleModel *a_ptr;
	a_ptr = ghpringbuf_at(compressed_sample_model__queue_buf, 0);
	memcpy(&rm, a_ptr, sizeof(CompressedSampleModel));

}
void compressed_sample_model__get_last(CompressedSampleModel *rm){
	CompressedSampleModel *a_ptr;
	a_ptr = ghpringbuf_at(compressed_sample_model__queue_buf, 10-1);
	memcpy(&rm, a_ptr, sizeof(CompressedSampleModel));
}

 


// replicated are only one instance of the model, logging makes new model
TransmitCSModel m_transmit_c_s_model;

void transmit_c_s_model__innit(){
	memset(&m_transmit_c_s_model, 0, sizeof(TransmitCSModel));
	//loop through the field to set default values
}
void transmit_c_s_model__destroy(){
	//since the model is replicated we dont have any buffer
}
void transmit_c_s_model__save(TransmitCSModel *rm) {
	//notify subscribers
   RavelContext rctx;
   rctx.error = NRF_SUCCESS;
   rctx.model = &m_transmit_c_s_model;
   transmit_c_s_model__coordinator_ctr__arrived(&rctx);
}

void transmit_c_s_model__get_first(TransmitCSModel *rm){
	memcpy(rm, &m_transmit_c_s_model, sizeof(m_transmit_c_s_model));
}
void transmit_c_s_model__get_last(TransmitCSModel *rm){
	memcpy(rm, &m_transmit_c_s_model, sizeof(m_transmit_c_s_model));
}
void transmit_c_s_model__get(uint32_t position, TransmitCSModel *rm){
     //TODO: raise an error from Ravel
     memcpy(rm, &m_transmit_c_s_model, sizeof(m_transmit_c_s_model));
}



 