/**
 * Autogenerated file containing data models
 *  models.c
 *
 *  Created on: 19:36:55 10/08/2016
 *      Author: Ravel
 */
//base includes
#include "stdlib.h"
#include "unistd.h"
//default buffers
#include "api/ringbuf.h"

#include "models.h"
#include "randomcontrollerembedded.h" //controller include
//Model common implementations
#define RANDOM_MODEL_QUEUE_SIZE 10

ghpringbuf *random_model__queue_buf ;
uint32_t random_model__buff_size = _QUEUE_SIZE;
bool random_model__buff_full = false;
uint32_t random_model__rec_id=0;
uint32_t random_model__rec_discarded=0;
//generic buffer implementation
ghpringbuf *buf;

inline static bool random_model__is_full(){
	return random_model__queue_buf->capacity == random_model__queue_buf->count;
}

void random_model__save( *mr) {

	if(!random_model__buff_full) {
		ghpringbuf_put(random_model__queue_buf, mr);
		random_model__rec_id++;
	} else {
		random_model__rec_discarded++;
	}
	random_model__buff_full = random_model__is_full();
	if(random_model__buff_full){
		random_model_ctr__random_model_full();
	}
	random_model__data_added();
}


int random_model__first( *a){
 *a_ptr;
	if( (a_ptr = ghpringbuf_at(random_model__queue_buf, 0)) ){
		a = a_ptr;
		ghpringbuf_pop(random_model__queue_buf);
		return 0;
	} else {
		return 1;
	}
}

int random_model__get(uint32_t position,  *rm){
 *a_ptr;
	if( (a_ptr = ghpringbuf_at(random_model__queue_buf, position)) ){
		memcpy(&rm, a_ptr, sizeof());
		return 0;
	} else {
		return 1;
	}
}

void random_model__queue_innit_sized(int size){
	random_model__buff_size = size;
	random_model__queue_buf = ghpringbuf_create(size, sizeof(), 1, NULL);
}

void random_model__queue_innit(){
	random_model__queue_buf = ghpringbuf_create(QUEUE_SIZE, sizeof(), 1, NULL);
}

void random_model__destroy_queue(){
ghpringbuf_destroy(random_model__queue_buf);
}

 


 modelInstance ;

void update_frequency_model__save( *rm) {
	cm.frequency = rm->frequency;
	//notify subscribers
   RavelContext rctx;
   rctx.error = NRF_SUCCESS;
   rctx.model = &cm;
   random_model_ctr__update_frequency_model_arrived(&rctx);
}

int update_frequency_model__first( *rm){
	memcpy(rm, &cm, sizeof(cm));
	return 0;
}
int update_frequency_model__get(uint32_t position,  *rm){
	if (position >1) return 1;
	else{
		rm = &cm;
		return 0;
	}
}

void update_frequency_model__queue_innit(){
	memset(&cm, 0, sizeof(cm));
		model_cmd_imp. = ; // default value ;separator="\n"
}
void update_frequency_model__destroy_queue(){
	//since the model is replicated we dont have any buffer
}
 modelInstance ;

 