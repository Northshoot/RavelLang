/**
 * Autogenerated file containing data models
 *  models.c
 *
 *  Created on: 21:53:05 10/06/2016
 *      Author: Ravel
 */
//base includes
#include "stdlib.h"
#include "unistd.h"
//default buffers
#include "api/ringbuf.h"

#include "models.h"
//Model common implementations
#define RANDOMMODEL_QUEUE_SIZE 10

ghpringbuf *m_random_model__queue_buf ;
uint32_t m_random_model__buff_size = RANDOMMODEL_QUEUE_SIZE;
bool m_random_model__buff_full = false;
uint32_t m_random_model__rec_id=0;
uint32_t m_random_model__rec_discarded=0;
//generic buffer implementation
ghpringbuf *buf;

inline static bool m_random_model__is_full(){
	return m_random_model__queue_buf->capacity == m_random_model__queue_buf->count;
}

void m_random_model__save(RandomModel *mr) {

	if(!m_random_model__buff_full) {
		ghpringbuf_put(m_random_model__queue_buf, mr);
		m_random_model__rec_id++;
	} else {
		m_random_model__rec_discarded++;
	}
	m_random_model__buff_full = m_random_model__is_full();
	if(m_random_model__buff_full){
		m_random_model_ctr__m_random_model_full();
	}
	m_random_model__data_added();
}


int m_random_model__first(RandomModel *a){
	RandomModel *a_ptr;
	if( (a_ptr = ghpringbuf_at(m_random_model__queue_buf, 0)) ){
		a = a_ptr;
		ghpringbuf_pop(m_random_model__queue_buf);
		return 0;
	} else {
		return 1;
	}
}

int m_random_model__get(uint32_t position, RandomModel *rm){
	RandomModel *a_ptr;
	if( (a_ptr = ghpringbuf_at(m_random_model__queue_buf, position)) ){
		memcpy(&rm, a_ptr, sizeof(RandomModel));
		return 0;
	} else {
		return 1;
	}
}

void m_random_model__queue_innit_sized(int size){
	m_random_model__buff_size = size;
	m_random_model__queue_buf = ghpringbuf_create(size, sizeof(RandomModel), 1, NULL);
}

void m_random_model__queue_innit(){
	m_random_model__queue_buf = ghpringbuf_create(RANDOMMODELQUEUE_SIZE, sizeof(RandomModel), 1, NULL);
}

void m_random_model__destroy_queue(){
ghpringbuf_destroy(m_random_model__queue_buf);
}

 


UpdateFrequencyModel modelInstance ;

void m_updatefrequency_model__save(UpdateFrequencyModel *rm) {
	cm.frequency = rm->frequency;
	//notify subscribers
   RavelContext rctx;
   rctx.error = NRF_SUCCESS;
   rctx.model = &cm;
   random_model_ctr__m_updatefrequency_model_arrived(&rctx);
}

int m_updatefrequency_model__first(UpdateFrequencyModel *rm){
	memcpy(rm, &cm, sizeof(cm));
	return 0;
}
int m_updatefrequency_model__get(uint32_t position, UpdateFrequencyModel *rm){
	if (position >1) return 1;
	else{
		rm = &cm;
		return 0;
	}
}

void m_updatefrequency_model__queue_innit(){
	memset(&cm, 0, sizeof(cm));
		model_cmd_imp. = ; // default value ;separator="\n"
}
void m_updatefrequency_model__destroy_queue(){
	//since the model is replicated we dont have any buffer
}
UpdateFrequencyModel modelInstance ;

 