
/**
 * master template for model headers
 */
models_header_file(space)::=<<
/**
 * Autogenerated file containing data models
 *  models.h
 *
 *  Created on: <space.timeDate>
 *      Author: Ravel
 */
#ifndef MODELS_H_
#define MODELS_H_
<base_includes()>
//generating structures for the models
<models:{model|<model.comment> <\n> <model_schema(m)> }; separator="\n\n">

//Create internal model packets
<models:{model|<model_meta_pkt(m)> }; separator="\n\n">

//define model command
<models:{model|<model_cmd_def(m)> }; separator="\n\n">
//end of autogenerated code
#endif /* MODELS_H_ */
>>
////////////END models h header file
/**
 * master template for model object
 */
models_header_file(space)::=<<
/**
 * Autogenerated file containing data models
 *  models.c
 *
 *  Created on: <space.timeDate>
 *      Author: Ravel
 */
<base_includes()>
#include "models.h"
<model_ctr_includes(space.models)>
//Model coman implementations
<models:{model|<model_cmd_imp(m)> }; separator="\n\n">
>>
////////////END models c object file
/**
 * partial templates
 */
//model command implementations
model_cmd_imp(model)::=<<
<! Initialize buffers for the model !>
<if(model.streaming || model.local)>
<! Streaming and local have sizes !>
#define <model.nameUpperCase>_QUEUE_SIZE <model.size>

ghpringbuf *<model.name_c>__queue_buf ;
uint32_t <model.name_c>__buff_size = RAMDOM_MODEL_QUEUE_SIZE;
bool <model.name_c>__buff_full = false;
uint32_t <model.name_c>__rec_id=0;
uint32_t <model.name_c>__rec_discarded=0;
//generic buffer implementation
ghpringbuf *buf;
<elseif(model.replicated)>
<! replicated are only one instance of the model, logging makes new model !>
<model.name> modelInstance ;
<else>
\<\<\<\< ERROR in model type! \>\>\>
<endif>

<! functions differ depending on local streaming or replicated !>

<if(model.streaming || model.local)>
inline static bool <model.name_c>__is_full(){
	return <model.name_c>__queue_buf->capacity == <model.name_c>__queue_buf->count;
}

void <model.name_c>__save(<model.name> *mr) {
	
	if(!<model.name_c>__buff_full) {
		ghpringbuf_put(<model.name_c>__queue_buf, mr);
		<model.name_c>__rec_id++;
	} else {
		<model.name_c>__rec_discarded++;
	}
	<model.name_c>__buff_full = <model.name_c>__is_full();
	if(<model.name_c>__buff_full){
		<model.name_c>_ctr__<model.name_c>_full();
	}
	<model.name_c>__data_added();
}


int <model.name_c>__first(<model.name> *a){
	<model.name> *a_ptr;
	if( (a_ptr = ghpringbuf_at(<model.name_c>__queue_buf, 0)) ){
		a = a_ptr;
		ghpringbuf_pop(<model.name_c>__queue_buf);
		return 0;
	} else {
		return 1;
	}
}

int <model.name_c>__get(uint32_t position, <model.name> *rm){
	<model.name> *a_ptr;
	if( (a_ptr = ghpringbuf_at(<model.name_c>__queue_buf, position)) ){
		memcpy(&rm, a_ptr, sizeof(<model.name>));
		return 0;
	} else {
		return 1;
	}
}

void <model.name_c>__queue_innit_sized(int size){
	<model.name_c>__buff_size = size;
	<model.name_c>__queue_buf = ghpringbuf_create(size, sizeof(<model.name>), 1, NULL);
}

void <model.name_c>__queue_innit(){
	<model.name_c>__queue_buf = ghpringbuf_create(<model.nameUpperCase>QUEUE_SIZE, sizeof(<model.name>), 1, NULL);
}

void <model.name_c>__destroy_queue(){
ghpringbuf_destroy(<model.name_c>__queue_buf);
}
<elseif(model.replicated)>
<! replicated are only one instance of the model, logging makes new model !>
void <model.name_c>__save(<model.name> *rm) {
	cm.frequency = rm->frequency;
	//notify subscribers
   RavelContext rctx;
   rctx.error = NRF_SUCCESS;
   rctx.model = &cm;
   random_model_ctr__<model.name_c>_arrived(&rctx);
}

int <model.name_c>__first(<model.name> *rm){
	memcpy(rm, &cm, sizeof(cm));
	return 0;
}
int <model.name_c>__get(uint32_t position, <model.name> *rm){
	if (position >1) return 1;
	else{
		rm = &cm;
		return 0;
	}
}

void <model.name_c>__queue_innit(){
	memset(&cm, 0, sizeof(cm));
	<model.schema:{s|
	model_cmd_imp.<s.name> = <s.defaultValue>; // default value ;separator="\n"} >
}
void <model.name_c>__destroy_queue(){
	//since the model is replicated we dont have any buffer
}
<model.name> modelInstance ;
<else>
\<\<\<\< ERROR in model type! \>\>\>
<endif>



>>
//model command definitions
model_cmd_def(model)::=<<
void <model.name_c>__save(<model.name> *modelP) ;
int <model.name_c>__first(<model.name> *modelP);
int <model.name_c>__get(uint32_t position, <model.name> *modelP);

void <model.name_c>__queue_innit_sized(int size);
void <model.name_c>__queue_innit();
void <model.name_c>__destroy_queue();
>>
model_meta_pkt(model)::=<<
typedef struct _metaConfigModel {
	uint32_t node_UUID;
	uint8_t origin;
	uint8_t rqACK;
	uint8_t size;
	<model.name> model;
}<model.name>Packet;

#define <model.nameUpperCase>_PACKET_SIZE sizeof(<model.name>Packet)
>>
//create model struct
model_schema(model)::=<<
typedef struct
{
<model.schema:{s| <s.type> \\
<s.name> //<s.comment> ;};separator="\n">
} <model.name>;


#define <model.nameCDefine>_SIZE sizeof(<model.name>)
>>

//common includes for base models
base_includes()::=<<
//base includes
#include "stdlib.h"
#include "unistd.h"
//default buffers
#include "api/ringbuf.h"

>>
model_ctr_includes(models)::=<<
<! For  each model add controller for call backs!>
<models:{model:#include "<model.model_controller.name_c>.h"};separator="\n">
>>

