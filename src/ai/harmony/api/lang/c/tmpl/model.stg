model_c_obj(model)::=<<
/*
 * <model.name>.c
 *
 *  Created on: Sep 7, 2016
 *      Author: lauril
 */
#include "stdlib.h"
#include "stdint.h"
#include "unistd.h"

#include "api/ringbuf.h"
#include "models.h"
#include "<model.name>_ctr.h"
//TODO: add error handling

#define <model.nameUpper>L_QUEUE_SIZE <model.size>

ghpringbuf *<model.CVarName>__queue_buf ;

uint32_t <model.CVarName>__buff_size = RAMDOM_MODEL_QUEUE_SIZE;
bool <model.CVarName>__buff_full = false;
uint32_t <model.CVarName>__rec_id=0;
uint32_t c__rec_discarded=0;


ghpringbuf *buf;

inline static bool <model.name>__is_full(){
	return <model.CVarName>__queue_buf->capacity == <model.CVarName>__queue_buf->count;
}

void <model.name>__save(<model.cStructName> *mr) {
	//SEGGER_RTT_WriteString(0,"RD_MD: save -- ");
	if(!<model.name>__buff_full) {
		ghpringbuf_put(<model.CVarName>__queue_buf, mr);
		<model.CVarName>__rec_id++;
		//SEGGER_RTT_printf(0," rec: %d model->rec_id %d OK\r\n", <model.name>__rec_id, mr->rec_id);
	} else {
		<model.name>__rec_discarded++;
		//SEGGER_RTT_WriteString(0,"error\r\n");
	}
	<model.name>__buff_full = <model.name>__is_full();
	if(<model.name>__buff_full){
		//SEGGER_RTT_WriteString(0,"full\r\n");
		<model.name>_ctr__<model.name>_full();
	}
	<model.name>__data_added();

}


int <model.name>__first(<model.cStructName> *a){
	<model.cStructName> *a_ptr;
	if( (a_ptr = ghpringbuf_at(<model.CVarName>__queue_buf, 0)) ){
		a = a_ptr;
		ghpringbuf_pop(<model.CVarName>__queue_buf);
		return 0;
	} else {
		return 1;
	}

}

int <model.name>__get(uint32_t possition, <model.cStructName> *rm){
	<model.cStructName> *a_ptr;
	if( (a_ptr = ghpringbuf_at(<model.CVarName>__queue_buf, possition)) ){
		memcpy(&rm, a_ptr, sizeof(<model.cStructName>));
		return 0;
	} else {
		return 1;
	}


}

void <model.name>__queue_innit_sized(int size){
	<model.name>__buff_size = size;
	<model.CVarName>__queue_buf = ghpringbuf_create(size, sizeof(<model.cStructName>), 1, NULL);
}

void <model.name>__queue_innit(){
	<model.CVarName>__queue_buf = ghpringbuf_create(<model.nameUpper>_QUEUE_SIZE, sizeof(<model.cStructName>), 1, NULL);
}

void <model.name>__destroy_queue(){
    ghpringbuf_destroy(<model.CVarName>__queue_buf);
}

>>

model_schema(model)::=<<
typedef struct
{
<model.schema:{s| <s.type> <s.name> //<s.comment> ;};separator="\n">
} <model.cStructName>;
>>
model_h_file(ir)::=<<
/*
 * models.h
 *
 *  Autogenerated on <ir.timeDate>
 *      Author: Ravel
 */

#ifndef MODELS_H_
#define MODELS_H_
#include <string.h>
#include <unistd.h>

/**
 * Creating model and schema
 */
 <! for each model create a schema struct !>
 <models:{m| (modelSchema)(m)};separator="\n">


typedef struct
{
	uint32_t frequency;
}ConfigModel;

typedef struct _metaConfigModel {
	uint32_t node_UUID;
	uint8_t origin;
	uint8_t rqACK;
	uint8_t size;
	ConfigModel model;
}RavelConfigPacket;


typedef struct _rCntx {
	uint32_t error;
	void* model;
} RavelContext;

typedef struct _metaRandomModel {
	uint32_t node_UUID;
	uint8_t origin;
	uint8_t rqACK;
	uint8_t size;
	RandomModel model;
}RavelRandomPacket;

#define RAVEL_PKT_SIZE sizeof(RavelPacket)
#define RANDOM_MODEL_SIZE sizeof(RandomModel)

void config_model__save(ConfigModel *rm) ;
int config_model__first(ConfigModel *rm);
int config_model__get(uint32_t possition, ConfigModel *rm);

void config_model__queue_innit_sized(int size);
void config_model__queue_innit();
void config_model__destroy_queue();

void random_model__save(RandomModel *rm) ;
int random_model__first(RandomModel *rm);
int random_model__get(uint32_t possition, RandomModel *rm);

void random_model__queue_innit_sized(int size);
void random_model__queue_innit();
void rondom_model__destroy_queue();

#endif /* MODELS_H_ */

>>
