
/**
 * master template for model headers
 */
models_header_file(space)::=<<
/**
 * Autogenerated file containing data models
 *  models.h
 *
 *  Created on: <space.timeDate>
 *      Author: Ravel
 */
#ifndef MODELS_H_
#define MODELS_H_
<base_includes()>
//generating structures for the models
<space.models:{model|
//<model.comment>
<model_schema(model)> }; separator="\n\n">

//Create internal model packets
<space.models:{model|<model_meta_pkt(model)> }; separator="\n\n">

//define model command
<space.models:{model|<model_cmd_def(model)> }; separator="\n\n">

//end of autogenerated code

#endif /* MODELS_H_ */
>>
////////////END models h header file
/**
 * master template for model object
 */
models_obj_file(space)::=<<
/**
 * Autogenerated file containing data models
 *  models.c
 *
 *  Created on: <space.timeDate>
 *      Author: Ravel
 */
<base_includes()>
#include "models.h"
<model_ctr_includes(space.controllers)>
//Model common implementations
<space.models:{model|<model_cmd_imp(model)> }; separator="\n\n">
>>
////////////END models c object file
/**
 * partial templates
 */
//model command implementations
model_cmd_imp(model)::=<<
<! Initialize buffers for the model !>
<if(model.streaming || model.local)>
<! Streaming and local have sizes !>
#define <model.defineName>_QUEUE_SIZE <model.size>

ghpringbuf *<model.cName>__queue_buf ;
uint32_t <model.cName>__buff_size = <model.modelNameUpperCase>_QUEUE_SIZE;
bool <model.cName>__buff_full = false;
uint32_t <model.cName>__rec_id=0;
uint32_t <model.cName>__rec_discarded=0;
//generic buffer implementation
ghpringbuf *buf;
<elseif(model.replicated)>
<! replicated are only one instance of the model, logging makes new model !>
<model.modelName> modelInstance ;
<else>
\<\<\<\< ERROR in model type! \>\>\>
<endif>

<! functions differ depending on local streaming or replicated !>

<if(model.streaming || model.local)>
inline static bool <model.cName>__is_full(){
	return <model.cName>__queue_buf->capacity == <model.cName>__queue_buf->count;
}

void <model.saveFunction>(<model.modelName> *mr) {
	
	if(!<model.cName>__buff_full) {
		ghpringbuf_put(<model.cName>__queue_buf, mr);
		<model.cName>__rec_id++;
	} else {
		<model.cName>__rec_discarded++;
	}
	<model.cName>__buff_full = <model.cName>__is_full();
	if(<model.cName>__buff_full){
		<model.cName>_ctr__<model.cName>_full();
	}
	<model.cName>__data_added();
}


int <model.cName>__first(<model.modelName> *a){
	<model.modelName> *a_ptr;
	if( (a_ptr = ghpringbuf_at(<model.cName>__queue_buf, 0)) ){
		a = a_ptr;
		ghpringbuf_pop(<model.cName>__queue_buf);
		return 0;
	} else {
		return 1;
	}
}

int <model.recordPosition>(uint32_t position, <model.modelName> *rm){
	<model.modelName> *a_ptr;
	if( (a_ptr = ghpringbuf_at(<model.cName>__queue_buf, position)) ){
		memcpy(&rm, a_ptr, sizeof(<model.modelName>));
		return 0;
	} else {
		return 1;
	}
}

void <model.cName>__queue_innit_sized(int size){
	<model.cName>__buff_size = size;
	<model.cName>__queue_buf = ghpringbuf_create(size, sizeof(<model.modelName>), 1, NULL);
}

void <model.cName>__queue_innit(){
	<model.cName>__queue_buf = ghpringbuf_create(<model.modelNameUpperCase>QUEUE_SIZE, sizeof(<model.modelName>), 1, NULL);
}

void <model.cName>__destroy_queue(){
ghpringbuf_destroy(<model.cName>__queue_buf);
}
<elseif(model.replicated)>
<! replicated are only one instance of the model, logging makes new model !>
void <model.cName>__save(<model.modelName> *rm) {
	cm.frequency = rm->frequency;
	//notify subscribers
   RavelContext rctx;
   rctx.error = NRF_SUCCESS;
   rctx.model = &cm;
   random_model_ctr__<model.cName>_arrived(&rctx);
}

int <model.cName>__first(<model.modelName> *rm){
	memcpy(rm, &cm, sizeof(cm));
	return 0;
}
int <model.cName>__get(uint32_t position, <model.modelName> *rm){
	if (position >1) return 1;
	else{
		rm = &cm;
		return 0;
	}
}

void <model.cName>__queue_innit(){
	memset(&cm, 0, sizeof(cm));
	<model.schema:{s|
	model_cmd_imp.<s.modelName> = <s.defaultValue>; // default value ;separator="\n"} >
}
void <model.cName>__destroy_queue(){
	//since the model is replicated we dont have any buffer
}
<model.modelName> modelInstance ;
<else>
\<\<\<\< ERROR in model type! \>\>\>
<endif>



>>
//model command definitions
model_cmd_def(model)::=<<
void <model.cName>__save(<model.modelName> *modelP) ;
int <model.cName>__first(<model.modelName> *modelP);
int <model.cName>__get(uint32_t position, <model.modelName> *modelP);

void <model.cName>__queue_innit_sized(int size);
void <model.cName>__queue_innit();
void <model.cName>__destroy_queue();
>>
model_meta_pkt(model)::=<<
typedef struct _metaConfigModel {
	uint32_t node_UUID;
	uint8_t origin;
	uint8_t rqACK;
	uint8_t size;
	<model.modelName> model;
}<model.modelName>Packet;

#define <model.modelNameUpperCase>_PACKET_SIZE sizeof(<model.modelName>Packet)
>>
//create model struct
model_schema(model)::=<<
typedef struct {
    <model.schema:{field| <field.cType> <field.cVarName> <field.cComment> ;};separator="\n">
} <model.modelName>;


#define <model.modelNameCDefine>_SIZE sizeof(<model.modelName>)
>>

//common includes for base models
base_includes()::=<<
//base includes
#include "stdlib.h"
#include "unistd.h"
//default buffers
#include "api/ringbuf.h"

>>
model_ctr_includes(controllers)::=<<
<! For  each model add controller for call backs!>
<controllers:{ctr|#include "<ctr.fileNameC>.h" //controller include};separator="\n">
>>

