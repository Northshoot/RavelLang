
/**
 * master template for model headers
 */
models_header_file(space)::=<<
/**
 * Autogenerated file containing data models
 *  models.h
 *
 *  Created on: <space.timeDate>
 *      Author: Ravel
 */
#ifndef MODELS_H_
#define MODELS_H_
<base_includes()>
//generating structures for the models
<space.models:{model|
//<model.comment>
<model_schema(model)> }; separator="\n\n">

//Create internal model packets
<space.models:{model|<model_meta_pkt(model)> }; separator="\n\n">

//define model command
<space.models:{model|<model_cmd_def(model)> }; separator="\n\n">

//end of autogenerated code

#endif /* MODELS_H_ */
>>
////////////END models h header file
/**
 * master template for model object
 */
models_obj_file(space)::=<<
/**
 * Autogenerated file containing data models
 *  models.c
 *
 *  Created on: <space.timeDate>
 *      Author: Ravel
 */
<base_includes()>
#include "models.h"
<model_ctr_includes(space.controllers)>
//Model common implementations
<space.models:{model|<model_cmd_imp(model)> }; separator="\n\n">
>>
////////////END models c object file
/**
 * partial templates
 */
//model command implementations
model_cmd_imp(model)::=<<
<! Initialize buffers for the model !>
<if(model.streaming || model.local)>
<! Streaming and local have sizes !>
#define <model.defineName>__QUEUE_SIZE <model.size>

ghpringbuf *<model.cName>__queue_buf ;
uint32_t <model.cName>__buff_size = <model.defineName>__QUEUE_SIZE;
bool <model.cName>__buff_full = false;
uint32_t <model.cName>__rec_id=0;
uint32_t <model.cName>__rec_discarded=0;

//generic buffer implementation
ghpringbuf *buf;
<elseif(model.replicated)>
// replicated are only one instance of the model, logging makes new model
<model.modelName> <model.cVarName>;
<else>
<! should never end up here !>
\<\<\<\< ERROR in model type! \>\>\>
<endif>

<! function implementation depends on the model type!>
<if(model.streaming || model.local)>
//is buffer full
inline static bool <model.cName>__is_full(){
	return <model.cName>__queue_buf->capacity == <model.cName>__queue_buf->count;
}

//buffer size is defined via <model.defineName>__QUEUE_SIZE
//init buffer
void <model.getInitFunction>(){
	<model.cName>__queue_buf = ghpringbuf_create(<model.modelNameUpperCase>QUEUE_SIZE, sizeof(<model.modelName>), 1, NULL);
}

//delete buffer
void <model.DestroyFunction>(){
    ghpringbuf_destroy(<model.cName>__queue_buf);
}
//*record functions:*/

//create record is in place code snippet
<model.modelName> <model.createFunction>(){
        <model.modelName> m_model;
        //allocate the memory
    	memset(&m_model, 0, sizeof(<model.modelName>));
    	//loop through the field to set default values
    	<model.schema:{field|<if(field.hasDefault)> <field.cVarName>=<field.defaultValue>; //setting default<endif>};separator="\n">
        //return newly created model with set fields
    	return m_model
}
//save record
void <model.saveFunction>(<model.modelName> *mr) {
	if(!<model.cName>__buff_full) {
		ghpringbuf_put(<model.cName>__queue_buf, mr);
		<model.cName>__rec_id++;
	} else {
		<model.cName>__rec_discarded++;
	}
	<model.cName>__buff_full = <model.cName>__is_full();
	if(<model.cName>__buff_full){
		<model.cName>_ctr__<model.cName>_full();
	}
	<model.bufferSaveDoneEvent>(mr);
}

//delete
void <model.deleteFunction>(int position) {
    ghpringbuf_pop(position);

}
//* record local queries */
void <model.recordPosition>(uint32_t position, <model.modelName> *rm){
	<model.modelName> *a_ptr;
	a_ptr = ghpringbuf_at(<model.cName>__queue_buf, position))
	memcpy(&rm, a_ptr, sizeof(<model.modelName>));

}
void <model.firstRecord>(<model.modelName> *a){
	<model.modelName> *a_ptr;
	a_ptr = ghpringbuf_at(<model.cName>__queue_buf, 0))
	memcpy(&rm, a_ptr, sizeof(<model.modelName>));

}
void <model.lastRecord>(<model.modelName> *a){
	<model.modelName> *a_ptr;
	a_ptr = ghpringbuf_at(<model.cName>__queue_buf, <model.size>-1))
	memcpy(&rm, a_ptr, sizeof(<model.modelName>));
}
<elseif(model.replicated)>
<! replicated are only one instance of the model, logging makes new model !>

void <model.initFunction>{
	memset(&<model.cVarName>, 0, sizeof(<model.modelName>));
	//loop through the field to set default values
     <model.schema:{field|<if(field.hasDefault)> <field.cVarName>=<field.defaultValue>; //setting default<endif>};separator="\n">
}
void <model.destroyFunction>(){
	//since the model is replicated we dont have any buffer
}
void <model.saveFunction>(<model.modelName> *rm) {
    <model.schema:{field|<if(field.hasDefault)> <model.cVarName>.<field.cVarName>=rm-><field.cVarName>; //setting default<endif>};separator="\n">
	//notify subscribers
   RavelContext rctx;
   rctx.error = NRF_SUCCESS;
   rctx.model = &<model.cVarName>;
   <model.arrivedEvent>(&rctx);
}

void <model.firstRecord>(<model.modelName> *rm){
	memcpy(rm, &<model.cVarName>, sizeof(<model.cVarName>));
}
void <model.cName>recordPosition(uint32_t position, <model.modelName> *rm){
     //TODO: raise an error from Ravel
     memcpy(rm, &<model.cVarName>, sizeof(<model.cVarName>));
}


<else>
\<\<\<\< ERROR in model type! \>\>\>
<endif>



>>
//model command definitions
model_cmd_def(model)::=<<
//init model
void <model.initFunction>();
//destroy buffer
void <model.destroyFunction>();

//*record functions:*/
//create record
void <model.createFunction>(<model.modelName> *modelP) ;
//save record
void <model.saveFunction>(<model.modelName> *modelP) ;
//delete
void <model.deleteFunction>(int position) ;

//* record local queries */
//get record with position position
void <model.recordPosition>(uint32_t position);
//get first record
void <model.firstRecord>();
//get last record
void <model.lastRecord>();

//* record events defined for each controller */
//TODO: add many to many relation support
//arrived event
void <model.arrivedEvent>();
//departed event
void <model.departedEvent>();
//buffer is full event
void <model.fullEvent>();
//save done event
void <model.saveDoneEvent>();
//data saved to the buffer event
void <model.bufferSaveDoneEvent>();
>>
model_meta_pkt(model)::=<<
typedef struct _metaConfigModel {
	uint32_t node_UUID;
	uint8_t origin;
	uint8_t rqACK;
	uint8_t size;
	<model.modelName> model;
}<model.modelName>Packet;

#define <model.defineName>_PACKET_SIZE sizeof(<model.modelName>Packet)
>>
//create model struct
model_schema(model)::=<<
typedef struct {
    <model.schema:{field| <field.cType> <field.cVarName> <field.cComment> ;};separator="\n">
} <model.modelName>;


#define <model.defineName>_SIZE sizeof(<model.modelName>)
>>

//common includes for base models
base_includes()::=<<
//base includes
#include "stdlib.h"
#include "unistd.h"
//default buffers
#include "api/ringbuf.h"

>>
model_ctr_includes(controllers)::=<<
<! For  each model add controller for call backs!>
<controllers:{ctr|#include "<ctr.fileNameC>.h" //controller include};separator="\n">
>>

