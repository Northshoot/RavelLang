controller_obj_c(controller)::=<<
/**
 * Autogenerated main file
 *
 *
 *  Created on: <controller.timeDate>
 *      Author: Ravel
 */
#include "app_timer.h"
#include "nrf_log.h"
#include "nrf_log_ctrl.h"

#include "models.h"
#include "api_ble.h"
#include "<controller.headerFileName>"

//implement subscribed model events


//ConfigModel localCm;

<controller.models:{model|<get_model_event_impl(model)>};separator="\n">

//generating source callbacks implementations
<controller.sources:{source|<get_call_impl(controller,source)>};separator="\n">

//*** End auto generated file <controller.objFileName> **//
>>
/**
 * particular controller header
 */
controller_header(controller)::=<<
/**
 * Autogenerated main file
 *
 *
 *  Created on: <controller.timeDate>
 *      Author: Ravel
 */

#include "models.h" //since we have same naming
#include "api/api_timer.h"
//here we only declare system subscribed event callbacks

//start with models
<controller.models:{model|<get_model_event(model)>};separator="\n">

//generating source callbacks declarions
<controller.sources:{source|<get_call_backs(source)>};separator="\n">

//**** end autogenerated file **//
 >>
 //source callbacks implementation
get_call_impl(contoller,source)::=<<
<source.callBacks:{cb|void <cb>(void * p_context){
    //TODO: translate event implementation
\} };separator="\n\n">
>>

 //source callbacks declarations
get_call_backs(source)::=<<
<source.callBacks:{cb| void <cb>(void * p_context);}>
 >>
 //model envent template
get_model_event_impl(model)::=<<
//translate actions for the subscribed events
//TODO: check if controller is bubscribed to the particular model event

//void random_model_ctr__set_config_model(ConfigModel *cm){
//TODO: fix controller inner body
	//memset(&localCm, 0, sizeof(ConfigModel));
	//localCm.time = cm->time;
	//localCm.frequency = cm->frequency;
//}


void <model.arrivedEvent>(void *rctx ){
	//if(rctx->error == NRF_SUCCESS){
	//	config_model__first(&localCm);
	//	random_ctr__stopTimerPeriodic();
	//	random_ctr__startTimerPeriodic(localCm.frequency);
	//}
	//NRF_LOG_INFO("Arrived frequency: %d \r\n", localCm.frequency);
	//config_model__sys_write_to_BLE(&m_ravel_service, &localCm);
}

void <model.departedEvent>(void *rctx){
	//do things when model data arrives
}
void <model.fullEvent>(void *rctx){
	//do things when model data arrives
}

void <model.saveDoneEvent>(void *rctx){
	//do things when model data arrives
}
void <model.bufferSaveDoneEvent>(void *rctx){
	//do things when model data arrives
}

//void random_model_ctr__system_timmer(){

//}

>>

get_source_callback(source)::=<<
uint32_t cntr=0;

void <source.callBackName>(void * p_context)
{
	//TODO: implement controllers
    // OUR_JOB: Step 3.F, Update temperature and characteristic value.
    int32_t random = rand();
    int32_t temperature;
    RandomModel*rm;
    rm = malloc(sizeof(RandomModel));
    sd_temp_get(&temperature); // Get temperature
    rm->time = 0;
    rm->rec_id =cntr++;
    rm->temperature = temperature;
    rm->random = random;
    random_model__save(rm);

}
void random_model_ctr__system_booted(void *rctx){
	random_ctr__startTimerPeriodic(localCm.frequency);
}
void random_model_ctr__timer_single_shoot__expired(void * p_context){

}
>>
get_model_event(model)::=<<
//* record events defined for each controller */
//TODO: add many to many relation support
//arrived event
void <model.arrivedEvent>(void *rctx);
//departed event
void <model.departedEvent>(void *rctx);
//buffer is full event
void <model.fullEvent>(void *rctx);
//save done event
void <model.saveDoneEvent>(void *rctx);
//data saved to the buffer event
void <model.bufferSaveDoneEvent>(void *rctx);
>>