import "common.stg"

append_params(comp) ::=<<
<if(comp.allParameters)>, <comp.allParameters:{p|<p; format="literal">}; separator=", "><endif>
>>

interface_field(comp) ::=<<
private final <comp.component.name> iface_<comp.varName> = new <comp.component.name>(this, <comp.instanceId><append_params(comp)>);
>>
model_field(comp) ::=<<
private final <comp.component.name> model_<comp.varName> = new <comp.component.name>(this<append_params(comp)>);
>>
controller_field(ctr) ::=<<
private final <ctr.name> ctr_<ctr.varName> = new <ctr.name>(<ctr.parameterValues; separator=", ">);
>>

sink_field(sink) ::=<<
private final SinkAPI sink_<sink.varName> = null;
>>

model_case_event(model, event, parameters) ::=<<
case <model.component.baseModel.id>:
    model_<model.varName>.<event>(<parameters>);
    break;
>>

set_component_controller(comp, prefix) ::=<<
<comp.controllerList:{c|<prefix>_<comp.varName>.setController_<c.varName>(ctr_<c.varName>);}; separator="\n">
>>

file(package,imports,name,models,interfaces,controllers,space) ::=<<
package <package>;

import java.util.Collection;
import org.stanford.ravel.rrt.tiers.Endpoint;
import org.stanford.ravel.rrt.tiers.Error;
import org.stanford.ravel.rrt.model.ModelBottomAPI;
import org.stanford.ravel.rrt.model.ModelRecord;
import org.stanford.ravel.rrt.RavelPacket;
import org.stanford.ravel.rrt.DispatcherAPI;
import org.stanford.ravel.rrt.SystemEventAPI;
import org.stanford.ravel.rrt.AbstractDispatcher;
import org.stanford.ravel.rrt.DriverAPI;
import org.stanford.ravel.rrt.SourceAPI;
import org.stanford.ravel.rrt.SinkAPI;
import org.stanford.ravel.rrt.Context;
import org.stanford.ravel.rrt.events.Event;
import org.stanford.ravel.rrt.events.NetworkEvent;
import org.stanford.ravel.rrt.KeyProvider;

<imports:do_import()>

public class <name> extends AbstractDispatcher implements DispatcherAPI, SystemEventAPI {
    <models:model_field(); separator="\n">
    <interfaces:interface_field(); separator="\n">
    <controllers:controller_field(); separator="\n">

    private final KeyProvider keyProvider;
    private DriverAPI driver;

    public AppDispatcher(KeyProvider keyProvider) {
        this.keyProvider = keyProvider;

        <models:set_component_controller("model"); separator="\n">
        <interfaces:set_component_controller("iface"); separator="\n">
    }

    @Override
    public KeyProvider getKeyProvider() {
        return keyProvider;
    }

    void setDriver(DriverAPI driver) {
        this.driver = driver;
    }

    void addAllEndpoints() {
        <models:{m|model_<m.varName>.addAllEndpoints();}; separator="\n">
    }

    @Override
    public String getAppName() {
        return "<space.name>";
    }

    @Override
    public Collection\<Endpoint> getEndpointsByName(String name) {
        return driver.getEndpointsByName(name);
    }

    /***********************************************************************/
    /************** AD callbacks to the models ****************************/
    /***********************************************************************/

    protected void models__notifyDeparted(NetworkEvent event){
        RavelPacket rp = event.data;
        Endpoint endpoint = event.endpoint;
        switch (rp.model_id) {
            <models:model_case_event("recordDeparted", "rp, endpoint"); separator="\n">
        }
    }

    protected void models__notifyArrived(NetworkEvent event){
        RavelPacket rp = event.data;
        Endpoint endpoint = event.endpoint;
        switch (rp.model_id) {
            <models:model_case_event("recordArrived", "rp, endpoint"); separator="\n">
        }
    }

    protected void models__notifySavedDurably(NetworkEvent event){
        RavelPacket rp = event.data;
        Error error = event.error;
        switch (rp.model_id) {
            <models:model_case_event("recordSavedDurably", "rp, error"); separator="\n">
        }
    }

    protected void models__notifyLoadFromStorage(NetworkEvent event){
        RavelPacket rp = event.data;
        switch (rp.model_id) {
            <models:model_case_event("recordLoaded", "rp"); separator="\n">
        }
    }

    protected void models__notifyFailedToSend(NetworkEvent event){
        RavelPacket rp = event.data;
        Endpoint endpoint = event.endpoint;
        Error error = event.error;
        switch (rp.model_id) {
            <models:model_case_event("recordFailedToSend", "rp, endpoint, error"); separator="\n">
        }
    }

    /***********************************************************************/
    /************** AD Commands from model to AD ***************************/
    /***********************************************************************/
    public Error model__sendData(RavelPacket data, Endpoint ep) {
        return driver.sendData(data, ep);
    }

    public void model__saveDurably(RavelPacket data) {
        driver.saveDurably(data);
    }

    public void model__deleteFromStorage(int modelId, int recordId) {
        driver.deleteFromDurableStorage(modelId, recordId);
    }

    /***********************************************************************/
    /************** System callbacks from Driver to AD *********************/
    /***********************************************************************/
    @Override
    public void started() {
        <dispatch_event_single_instance(space.systemAPI.component, "started", [])>
    }

    @Override
    public void stopped() {
        <dispatch_event_single_instance(space.systemAPI.component, "stopped", [])>
    }

    @Override
    public void restarted() {
        <dispatch_event_single_instance(space.systemAPI.component, "restarted", [])>
    }

    @Override
    public void battery(SystemEventAPI.BatteryLevel bl) {}
};
>>