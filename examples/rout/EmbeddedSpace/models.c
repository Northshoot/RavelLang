/**
 * Autogenerated file containing data models
 *  models.c
 *
 *  Created on: 13:14:31 10/12/2016
 *      Author: Ravel
 */
//base includes
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
//default buffers
#include "api/ringbuf.h"

#include "models.h"
#include "random_controller_embedded_ctr.h" //controller include
//Model common implementations
#define RANDOM_MODEL__QUEUE_SIZE 10

ghpringbuf *random_model__queue_buf ;
uint32_t random_model__buff_size = RANDOM_MODEL__QUEUE_SIZE;
bool random_model__buff_full = false;
uint32_t random_model__rec_id=0;
uint32_t random_model__rec_discarded=0;

//generic buffer implementation
ghpringbuf *buf;
//*record functions:*/
//delete buffer
void random_model__destroy(){
    ghpringbuf_destroy(random_model__queue_buf);
}
//is buffer full
inline static bool random_model__is_full(){
	return random_model__queue_buf->capacity == random_model__queue_buf->count;
}

//buffer size is defined via RANDOM_MODEL__QUEUE_SIZE
//init buffer
void random_model__innit(){
	random_model__queue_buf = ghpringbuf_create(RANDOM_MODEL__QUEUE_SIZE, sizeof(RandomModel), 1, NULL);
}
//create record is in place code snippet
RandomModel random_model__create(){
        RandomModel m_model;
        //allocate the memory
    	memset(&m_model, 0, sizeof(RandomModel));
    	//loop through the field to set default values
        //return newly created model with set fields
    	return m_model;
}
//save record
void random_model__save(RandomModel *mr) {
	if(!random_model__buff_full) {
		ghpringbuf_put(random_model__queue_buf, mr);
		random_model__rec_id++;
	} else {
		random_model__rec_discarded++;
	}
	random_model__buff_full = random_model__is_full();
	if(random_model__buff_full){
		random_model__random_controller_cloud_ctr__full(mr);
	}
	random_model__random_controller_cloud_ctr__bufferSaveDone(mr);
}

//delete
void random_model__delete(int position) {
    //TODO: fix buffer pop at possition
    //ghpringbuf_pop(position);

}

//* record local queries */
void random_model__get(uint32_t position, RandomModel *rm){
	RandomModel *a_ptr;
	a_ptr = ghpringbuf_at(random_model__queue_buf, position);
	memcpy(&rm, a_ptr, sizeof(RandomModel));

}
void random_model__get_first(RandomModel *rm){
	RandomModel *a_ptr;
	a_ptr = ghpringbuf_at(random_model__queue_buf, 0);
	memcpy(&rm, a_ptr, sizeof(RandomModel));

}
void random_model__get_last(RandomModel *rm){
	RandomModel *a_ptr;
	a_ptr = ghpringbuf_at(random_model__queue_buf, 10-1);
	memcpy(&rm, a_ptr, sizeof(RandomModel));
}

 


// replicated are only one instance of the model, logging makes new model
FrequencyModel m_frequency_model;

void frequency_model__innit(){
	memset(&m_frequency_model, 0, sizeof(FrequencyModel));
	//loop through the field to set default values
}
void frequency_model__destroy(){
	//since the model is replicated we dont have any buffer
}
void frequency_model__save(FrequencyModel *rm) {
	//notify subscribers
   RavelContext rctx;
   rctx.error = NRF_SUCCESS;
   rctx.model = &m_frequency_model;
   frequency_model__random_controller_cloud_ctr__arrived(&rctx);
}

void frequency_model__get_first(FrequencyModel *rm){
	memcpy(rm, &m_frequency_model, sizeof(m_frequency_model));
}
void frequency_model__get_last(FrequencyModel *rm){
	memcpy(rm, &m_frequency_model, sizeof(m_frequency_model));
}
void frequency_model__get(uint32_t position, FrequencyModel *rm){
     //TODO: raise an error from Ravel
     memcpy(rm, &m_frequency_model, sizeof(m_frequency_model));
}



 


#define BOOT_ERROR_MODEL__QUEUE_SIZE 

ghpringbuf *boot_error_model__queue_buf ;
uint32_t boot_error_model__buff_size = BOOT_ERROR_MODEL__QUEUE_SIZE;
bool boot_error_model__buff_full = false;
uint32_t boot_error_model__rec_id=0;
uint32_t boot_error_model__rec_discarded=0;

//generic buffer implementation
ghpringbuf *buf;
//*record functions:*/
//delete buffer
void boot_error_model__destroy(){
    ghpringbuf_destroy(boot_error_model__queue_buf);
}
//is buffer full
inline static bool boot_error_model__is_full(){
	return boot_error_model__queue_buf->capacity == boot_error_model__queue_buf->count;
}

//buffer size is defined via BOOT_ERROR_MODEL__QUEUE_SIZE
//init buffer
void boot_error_model__innit(){
	boot_error_model__queue_buf = ghpringbuf_create(BOOT_ERROR_MODEL__QUEUE_SIZE, sizeof(BootErrorModel), 1, NULL);
}
//create record is in place code snippet
BootErrorModel boot_error_model__create(){
        BootErrorModel m_model;
        //allocate the memory
    	memset(&m_model, 0, sizeof(BootErrorModel));
    	//loop through the field to set default values
        //return newly created model with set fields
    	return m_model;
}
//save record
void boot_error_model__save(BootErrorModel *mr) {
	if(!boot_error_model__buff_full) {
		ghpringbuf_put(boot_error_model__queue_buf, mr);
		boot_error_model__rec_id++;
	} else {
		boot_error_model__rec_discarded++;
	}
	boot_error_model__buff_full = boot_error_model__is_full();
	if(boot_error_model__buff_full){
		boot_error_model__random_controller_embedded_ctr__full(mr);
	}
	boot_error_model__random_controller_embedded_ctr__bufferSaveDone(mr);
}

//delete
void boot_error_model__delete(int position) {
    //TODO: fix buffer pop at possition
    //ghpringbuf_pop(position);

}

//* record local queries */
void boot_error_model__get(uint32_t position, BootErrorModel *rm){
	BootErrorModel *a_ptr;
	a_ptr = ghpringbuf_at(boot_error_model__queue_buf, position);
	memcpy(&rm, a_ptr, sizeof(BootErrorModel));

}
void boot_error_model__get_first(BootErrorModel *rm){
	BootErrorModel *a_ptr;
	a_ptr = ghpringbuf_at(boot_error_model__queue_buf, 0);
	memcpy(&rm, a_ptr, sizeof(BootErrorModel));

}
void boot_error_model__get_last(BootErrorModel *rm){
	BootErrorModel *a_ptr;
	a_ptr = ghpringbuf_at(boot_error_model__queue_buf, -1);
	memcpy(&rm, a_ptr, sizeof(BootErrorModel));
}

 