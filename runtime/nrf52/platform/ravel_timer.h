#ifndef RAVEL_TIMER_H
#define RAVEL_TIMER_H

#include <stdbool.h>
#include "boards.h"
#include "nrf_drv_gpiote.h"
#include "app_error.h"
#include "app_timer.h"
#include "nrf_drv_clock.h"
#include "ravel_error.h"
#include "module.h"



/**
 * Driver abstraction for the timer
 */
//TODO: should configurable on the application level

//How many timers can we virtualize?
//TODO: dynamic timer allocation
#define MAX_TIMERS 4
#define APP_TIMER_ENABLED 1



#ifdef __cplusplus
extern "C" {
#endif

typedef void (*fired_callback)(void *data);
//timer structure
typedef struct {
    int __id;
    uint32_t t0;
    uint32_t dt;
    bool __is_one_shoot;
    bool __is_running;
    bool __reserved;
    fired_callback call_back;
    void *__timer;
} DriverTimer;

//TODO: could be optimized with a linked list
DriverTimer* m_timers[MAX_TIMERS];

/**
 * innitialize timer module
 * @return RAVEL_DRIVER_ERROR
 */
RAVEL_DRIVER_ERROR init_module();
/**
 * Create new timer with ID
 * @param timer
 * @param id autogenerated timer ID
 * @return
 */
RAVEL_DRIVER_ERROR init_timer_module();
RAVEL_DRIVER_ERROR create_new_timer(DriverTimer *timer, int timer_id, fired_callback callback, void *timer_ptr);
RAVEL_DRIVER_ERROR timer_start_periodic(DriverTimer *timer,uint32_t time);
RAVEL_DRIVER_ERROR timer_start_single_shoot(DriverTimer *timer, uint32_t time);
RAVEL_DRIVER_ERROR timer_cancel(DriverTimer *timer);
RAVEL_DRIVER_ERROR timer_cancel_all(void);

#ifdef __cplusplus
}
#endif
#endif //RAVEL_TIMER_H